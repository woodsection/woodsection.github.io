[ { "title": "Maven Local", "url": "/posts/maven-local/", "categories": "Web, Java, Build", "tags": "Web", "date": "2022-09-18 17:16:00 +0900", "snippet": "개요spring 으로 만들어진 레거시 프로젝트를 살펴보다가, 패키지를 가져올때 maven repo가 아닌 로컬에서 빌드해둔 jar 파일을 import 해오는 구문을 발견했습니다.살펴보던 프로젝트는 msa에서 하나의 서비스 부분이였는데, 구글 protobuf로 만들어둔 dto 클래스 모음 프로젝트를 로컬에 jar로 빌드하고 해당 jar을 각 프로젝트마다 로컬에서 import 해와 사용하는 형태로 구성되어있었습니다.패키지를 import 해올때 repo 같은 설정은 크게 신경쓰지 않았던 부분인데, 이번 기회에 간단하게나마 정리해두려고합니다.gradle 빌드gradle에서 로컬의 maven 저장소로 빌드하는 방법은 간단합니다.gradle publishToMavenLocalrepo 설정확인프로젝트 빌드는 gradle로 진행한다고 가정하겠습니다.build.gradle...repositories { mavenLocal() mavenCentral()  ...}...build.gradle 파일을 살펴보면 repositories를 설정하는 필드가 있는데, 해당 부분에 mavenCentral, mavenLocal이 있습니다.mavenLocal 이 설정되어있으면 로컬에 있는 패키지를 import 할 수 있는 상태가 됩니다.dependencies 임포트mac기준 default로 ~/.m2/repository path에 package들이 저장되며, 각 디렉토리마다 . 으로 구분하여 gradle의 dependencies 필드에 추가해줍니다.dependencies {    ...    implementation \"com.woodsection.test.application:0.0.1\"    ...}" }, { "title": "curl 커맨드의 --user 옵션", "url": "/posts/curl/", "categories": "Linux", "tags": "Linux, Command", "date": "2022-09-18 16:16:00 +0900", "snippet": "Curl 커맨드curl 명령어는 다음과 같이 사용되며 기본적으로 REST 서비스로 api 요청 테스트등을 위해 사용됩니다.curl [options] &lt;url&gt;–user 옵션api test를 위해서 curl 명령어 README를 작성하다가 찾게된 내용중에 생소한 --user 옵션이 있어 해당내용에 대해 간단히 기록하려고합니다.-u , --user 옵션을 통해 유저의 계정정보를 담아서 보낼 수 있으며, 쿼리 파라미터를 통해 보내는 것과 같이 동작하게 됩니다.#curl -u &lt;username:userpassword&gt; &lt;url&gt;curl -u testuser:userpassword https://test.com" }, { "title": "Istio 에서의 authentication", "url": "/posts/istio-security-authentication/", "categories": "Infra, Istio, Security", "tags": "ServiceMesh, Istio, Kubernetes", "date": "2022-07-26 22:32:00 +0900", "snippet": "Authentication (인증)기본 컨셉Istio에서는 두 가지 authentication(인증) 방식을 제공합니다. Peer authenticaion 클라이언트의 연결을 확인하기 위해 서비스간 인증에 사용되는 인증방식입니다. Istio에서는 서비스 코드의 변경없이 활성화가능한 상호간 TLS를 제공합니다. 서비스간 통신 보호 클러스터 - 클라우드 사이에 운용가능한 ID를 각 서비스에 제공 키, 인증서를 생성 및 배포, 순환을 자동화하는 시스템 제공 Request authentication end 유저를 위한 사용자 인증에 사용됩니다.JWT를 이용한 유효성 검사, 권한확인 혹은 OpenID Connect 공급자를 사용해 개발자 환경을 제공합니다.예시로 ORY Hydra, Keycloak, Auth0, Firebase Auth, Google Auth 등 ..Istio는 인증정책은 Istio config store에 k8s CRD를 이용해 저장하며, istiod는 키를 통해 각각의 프록시를 최신 정보로 업데이트합니다.Mutual TLS authentication (상호간 TLS 인증)Istio에서는 Envoy 프록시로 구현하는 클라이언트와 서버측의 PEP를 이용해 서비스간 통신을 터널링합니다.Mutual TLS 인증으로 다른 워크로드에 request 할때의 동작방식은 다음과 같습니다. 클라이언트의 로컬 사이드카 Envoy로 아웃바운드를 다시 라우팅합니다. 클라이언트 Envoy와 서버 Envoy가 TLS handshake를 수행합니다. 핸드쉐이크가 일어나는동안, 클라이언트 Envoy 에서는 secure naming 검사를 통해 서버 인증서의 service account가 대상의 서비스를 실행할 권한이 있는지 확인합니다. 각 Envoy는 TLS 연결을 설정하고, 클라이언트의 Envoy는 서버의 Envoy로 트래픽을 전달합니다. 서버 Envoy가 요청을 승인하고, 로컬 TCP 연결로 트래픽을 백엔드 서비스로 전달합니다.Permissive mode (허용모드)서비스가 일반 트래픽과 Mutual TLS 트래픽을 모두 수락할 수 있는 모드입니다.Secure namingserver identity는 인증서로 인코딩되지만, 서비스의 이름은 서비스나 DNS를 통해 검색됩니다.secure naming은 server indentity를 서비스 이름에 매핑하며, 이는 server identity가 서비스를 실행할 권한이 있음을 의미합니다.마스터 노드에서 apiserver를 감시하고 sercure naming을 생성하여 PEP에 배포합니다.서비스를 호출할때, 인증서에서 ID를 추출하고, secure naming과 비교하여 봄으로서 서비스 실행가능 여부를 검증하므로, secure naming을 통해 DNS spoofing, BGP/route hijacking, ARP spoofing 등의 공격으로부터 보호할 수 있는 수단이됩니다.Authentication architecture (인증 아키텍처)peer와 authorization policy를 사용해서 워크로드에 대한 인증 설정을 지정할 수 있습니다.yaml 파일을 통해 policy를 지정하고 정책이 배포되면 istio 구성 스토리지에 저장되며, istio controller에서 구성 스토리지를 감시합니다.policy의 변경시 istio는 변경된 policy를 엔드포인트에 비동기식으로 보내고, 프록시가 수신하면 해당 policy가 포드에 즉시 적용됩니다.이러한 요청은 다음과 같은 아키텍처를 통해 이뤄집니다.Authentication policies (인증정책)인증정책은 서비스가 수신하는 request에 적용되며, mutural TLS에서 클라이언트 측의 인증 규칙을 지정하기 위해선 DestinationRule 을 설정해야합니다.앞서 이야기했듯이 yaml 파일 형식으로 k8s의 CRD를 통해 지정할 수 있습니다.apiVersion: security.istio.io/v1beta1kind: PeerAuthenticationmetadata: name: \"example-peer-policy\" namespace: \"foo\"spec: selector: matchLabels: app: reviews mtls: mode: STRICTPolicy storage (정책 저장)istio root 네임스페이스에 mesh-scope policy를 저장합니다.이 정책은 전역적으로 설정되며, 네임스페이스를 지정하여 policy를 저장하면, 해당 네임스페이스 내의 워크로드내에서만 적용이 됩니다.selector 필드를 이용하여 네임스페이스를 지정할 수 있습니다.Selector field다음과 같이 selector 필드를 이용해 정책이 적용되는 워크로드 레이블을 지정할 수 있습니다.selector: matchLabels: app: product-page selector 필드에 값이 없으면, 루트 네임스페이스에 대해 지정된 정책이 적용됩니다.다음과 같은 순서로 각 워크로드에 정책을 적용합니다. 워크로드별 네임스페이스 전체 메쉬 전체정책이 여러가지가 적용되면, 모든 정책을 결합해서 적용되므로 여러 네임스페이스의 정책을 가질수도 있지만 권장하지는 않습니다.Peer authentication (피어 인증)피어인증에서는 mutural TSL 모드를 지정하며, 지원되는 모드는 다음과 같습니다. PERMISSIVE(허용) Mutural TSL, 일반 트래픽 모두 허용하며, 사이드카가 없는 워크로드에서 사용하기에 적합합니다. 사이드카가 적용이 된 후에는 STRICT 모드로 변경해야합니다. STRICT(엄격) Mutural TSL만을 허용합니다. DISABLE(비활성화) Mutural TSL이 비활성화되므로 자체적인 보안 솔루션이 없다면 비활성화모드를 사용해선 안됩니다. 모드가 적용되지않으면 상위의 모드가 상속되며, 상속될 모드도 없다면 PERMISSIVE 모드로 적용됩니다.다음의 설정에선 foo 네임스페이스 상의 워크로드에게 STRICT 모드가 적용됩니다.apiVersion: security.istio.io/v1beta1kind: PeerAuthenticationmetadata: name: \"example-policy\" namespace: \"foo\"spec: mtls: mode: STRICT특정 포트만을 지정하여 모드를 지정하는 것도 가능합니다.다음의 설정에선 foo 네임스페이스에 속하는 80 포트의 워크로드에서 Mutural TSL을 비활성화했습니다.apiVersion: security.istio.io/v1beta1kind: PeerAuthenticationmetadata: name: \"example-workload-policy\" namespace: \"foo\"spec: selector: matchLabels: app: example-app portLevelMtls: 80: mode: DISABLE다음의 구성에선 Mutural TSL이 비활성화된 80 포트로 바인딩되므로 요청이 성공적으로 작동합니다.apiVersion: v1kind: Servicemetadata: name: example-service namespace: foospec: ports: - name: http port: 8000 protocol: TCP targetPort: 80 selector: app: example-appRequest authenticationJWT의 유효성을 검사하기 위해 필요한 값을 지정하며, 그 값은 다음과 같습니다. request에서의 token의 위치 issuer와 request 공개 JSON 웹 키 set(JWKS)istio에서 규칙에 따라 토큰을 확인하고 유효성 여부를 판단합니다.request에 token이 없으면, 기본적으로 허용되며, 토큰이 없는 요청을 거부하려면 path, action 등을 지정하는 규칙을 지정해야합니다.둘 이상의 정책이 워크로드에 적용되어있다면, 각 정책에 따라 둘 이상의 JWT를 지정할 수 있으며, 단일 정책처럼 모든 규칙을 결합합니다.하지만, 둘 이상의 JWT가 있는 요청은 지원하지 않습니다.즉, 정책이 2개가 적용된 워크로드에 대하여 각 정책에 적용되는 JWT 1개 씩 총 2개는 가능하지만,정책이 2개가 적용된 워크로드에 대하여 각 정책에 적용되는 JWT 2개씩 총 4개는 불가능합니다.Principalspeer authentication policy, mutural TLS 등을 사용할 때, identity를 가져오기 위해 source.principal , request.auth.principal 등과 같은 보안 주체를 사용합니다.Updating authentication policies (인증정책 업데이트)authentication policy는 언제든 변경될 수 있으며, 거의 실시간으로 적용됩니다.하지만, 모든 워크로드가 새로운 정책을 수신했는지 보장할 순 없습니다.때문에 istio에서는 다음과 같이 권장합니다. 모드를 DISABLE → STRICT 또는 그 반대의 경우로 변경하고자한다면, 중간에 PERMISSIVE 모드로 지정한 뒤 바꿔야합니다. Istio telemetry를 통해 모드가 성공적으로 바뀌었는지 확인할 수 있습니다. request authentication을 다른 jwt로 마이그레이션하고자할때, 이전 규칙을 냅둔 상태로 새 jwt 정책을 추가한 뒤, 모든 트래픽이 새로운 jwt로 적용되고 난 이후에 이전 규칙을 제거해야합니다.단, 새로운 jwt는 이전의 jwt와 다른 위치를 사용해야합니다." }, { "title": "Istio의 Security", "url": "/posts/istio-security/", "categories": "Infra, Istio, Security", "tags": "ServiceMesh, Istio, Kubernetes", "date": "2022-07-25 23:05:00 +0900", "snippet": "보안(Security)istio를 사용했을 때의 보안적인 특징 애플리케이션과 인프라 코드의 수정없이 기본적으로 보안이 적용됨 기존 보안 시스템과 통합하여 보안 적용 신뢰할 수 없는 네트워크에도 보안을 적용할 수 있음아키텍쳐 CA(Certificate Authority) key와 인증 관리 설정 API 서버에서 프록시로 정책을 전달함 authentication policies(authentication policies) authorization policies(authorization policies) secure naming information(secure naming information) 사이드카와 perimeter 프록시는 PEPs에 따라 클라이언트와 서버간에 안전한 커뮤니케이션 Envoy proxy 확장세트는 원격측정과 감시를 관리함 control plane에서 API서버와 PEPs에 따른 data plane을 관리 PEPs는 Envoy를 통해 구현됨Istio identity워크로드간 통신을 위해서는 각자가 신용할 수 있는지 확인하기 위해 서로의 credential을 교환해야함클라이언트서버의 ID가 **secure naming을 통해 워크로드에 인증되어있는지 확인함서버서버에서는 클라이언트가 특정 정보에 액세스할 수 있는지에 대해 authorization policies를 통해 확인함누가 언제 액세스했는지, 워크로드를 사용한 것에 대한 비용 부과, 비용을 지불하지 못한 클라이언트의 거부 등을 수행함istio identity는 첫번째로 service identity 를 request origin의 identity를 결정함매우 유연하고 세분화된 service identities를 개인, 그룹 유저에게 제공해줌istio는 service identity 가 없는 플랫폼에선 여러 다른 인스턴스를 통해 identity를 결정하는데, 그 목록은 다음과 같음 K8s → kubernetes service account GCE → GCP service account On-promises(non-k8s) → user account, custom service account, service name, istio service account, or GCP service accountIdentity and certificate management(신원, 인증관리)모든 워크로드에서 X.509 certificate를 사용 istiod 에서 CSR을 받는 gRPC 서비스를 제공 [istio-agent → istiod] private key, CSR 전송 [istiod] istio의 Certificate Authority를 통해 인증서 발급 워크로드가 시작되면 Envoy는 SDS API를 통해 istio-agent에 인증서와 키를 요청함 istio-agent는 istiod 로부터 받은 인증서와 키를 SDS api를 통해 envoy로 전송 istio-agent 에서 워크로드 인증서의 만료여부를 모니터링함 위의 과정들이 반복되며 인증서와 키가 순환됨" }, { "title": "Maven이란 ?", "url": "/posts/maven/", "categories": "Web, Java, Build", "tags": "Web", "date": "2022-07-17 01:16:00 +0900", "snippet": "MavenMaven이란 Java용 프로젝트 관리도구로 Apache Ant의 대안으로 만듦 프로젝트 전체적인 Life Cycle 관리도구 pom.xml을 이용해 라이브러리를 자동으로 다운로드 각 라이브러리의 dependency 또한 알아서 다운로드 중앙 저장소를 통한 dependency 관리(아파치재단 운영) 자체적 중앙 저장소 구축 가능 (local repo) 간단 설정으로 배포관리 가능Maven vs AntAnt 전처리, 컴파일, 패키징, 테스팅, 배포Maven Life Cycle에 따라 작업을 수행하고, 전반적 프로젝트 관리기능을 포함 Build Tool + Project ManagementMaven Life CycleLife Cycle 메이븐은 프레임워크이므로 동작방식이 정해져 있음 이를 Life Cycle이라고 함 1 Validate 프로젝트 유효성, 필요한 모든 정보 사용가능 여부 검증 2 Compile 프로젝트 소스코드 컴파일 3 Test 유닛(단위) 테스트 수행단계, 실패시 빌드 실패처리, 스킵가능 4 Package 컴파일 소스코드와 리소스를 jar, war 등의 배포를 위한 패키지로 만듦 5 Integration Test 통합 테스트 단계 6 Verify 통합 테스트 결과에 대한 검사. 품질 기준 충족 검증 7 Install 패키지를 로컬 저장소에 설치 8 Deploy 만든 패키지를 원격 저장소에 release Phase(단계) Life Cycle의 각 단계(Validate, Compile …)를 phase 라고함 phase는 이전 단계에 대한 dependency가 있어 이전 단계가 수행되어야함Goal Maven에게 동작을 수행시키는 명령 실행 방식, 체인 형태로 실행 각각의 Phase에 연계된 Goal을 실행하는 과정을 Build 라고함Maven Configuration Filesettings.xml Maven 빌드 툴과 관련한 설정파일 MAVEN_HOME/confg 디렉토리에 위치💡 Maven 빌드시 플러그인을 중앙 저장소에서 로컬PC로 다운로드하는 default 경로는`USER_HOME/.m2/repository` 이며, settiings.xml 에서 경로 변경가능pom.xml 프로젝트의 모든 설정, 의존성 등을 알 수 있음&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\t\t&lt;version&gt;2.2.4.RELEASE&lt;/version&gt;\t\t&lt;relativePath/&gt;\t&lt;/parent&gt;\t&lt;groupId&gt;com.god&lt;/groupId&gt; \t&lt;artifactId&gt;bo&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;packaging&gt;war&lt;/packaging&gt;\t&lt;name&gt;bo&lt;/name&gt;\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\t&lt;url&gt;http://goddaehee.tistory.com&lt;/url&gt;\t&lt;properties&gt;\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;\t&lt;dependencies&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\t\t\t&lt;scope&gt;provided&lt;/scope&gt;\t\t&lt;/dependency&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\t\t\t&lt;scope&gt;test&lt;/scope&gt;\t\t\t&lt;exclusions&gt;\t\t\t\t&lt;exclusion&gt;\t\t\t\t\t&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;\t\t\t\t\t&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;\t\t\t\t&lt;/exclusion&gt;\t\t\t&lt;/exclusions&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;| modelVersion | POM model 버전 || — | — || parent | 프로젝트 계층정보 || parent.groupId | 프로젝트 생성조직 고유 아이디. 일반적으로 도메인 이름을 거꾸로 적음 || parent.artifactId | 프로젝트 빌드시 파일 대표이름. groupid 내에서 유일해야함. Maven 빌드시 default로 [artifactid]-[version]-[packaging].war 로 생성 || parent.version | 프로젝트 현재 버전. 개발중일때는 SNAPSHOT 접미사 사용 || packaging | 패키징 유형(jar, war, ear 등) || name | 프로젝트 이름 || description | 프로젝트 간략 설명 || url | 프로젝트 reference 사이트 || properties | 버전관리에 용이함. 위에 예시처럼 선언하고, dependencies 에서 다음과 같이 사용가능 ${java.version} || dependencies | 프로젝트와 의존 관계에있는 라이브러리들 관리 || build | 빌드에 사용할 플러그인 모음 |ReferenceMaven-integration-test[Maven] Maven 이란? (정의, 예제)" }, { "title": "Spring Boot Cors 정책 적용", "url": "/posts/spring_boot_cors/", "categories": "Web, Java, Spring Boot", "tags": "Web", "date": "2022-07-16 12:30:00 +0900", "snippet": "Spring Boot Cors현재 WebMvcConfigurerAdapter는 Deprecated WebMvcConfigurer 는 자동구성된 스프링 MVC 구성에 Formatter, MessageConverter 등을 추가등록할 수 있다. WebMvcRegistrations는 RequestMappingHandlerMapping, RequestMappingHandlerAdapter와 ExceptionHandlerExceptionResolver를 재정의할 때 사용한다.WebMvcConfigurr와 WebMvcRegistrations 소스를 살펴보면 메서드들을 default 메서드로 선언했다. 필요한 메서드만 구현해서 사용하라는 의미다.Java7을 지원하는 스프링 부트 1.5 에서는 [default 메서드(https://goo.gl/A7CL31)](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)가 없었기에 WebMvcConfigurer를 사용하려면 인터페이스에 선언된 메서드를 모두 구현해야 했다. 그런 불편함을 해소하고자 WebMvcConfigurerAdapter 추상 클래스를 제공했다. 이 추상 클래스를 상속받아 필요한 메서드만 오버라이드했다.스프링 부트 2.0부터 Java8과 스프링 5.0을 사용하면서 WebMvcConfigurer 메서드에 default를 선언했다. 그 덕분에 WebMvcConfigurer를 구현하는 클래스에서 모든 메서드를 구현해야하는 강제력이 사라졌다. 쓰임새가 사라진 WebMvcConfigurerAdapter 클래스는 스프링 부트 2.0에서 제외(Deprecated)되었다.Spring Boot Cors 정책 허용 WebSecurityConfigurerAdapter를 상속받고, Spring Security가 적용된 WebSecirityConfig.java CorsConfigurationSource를 스프링 Bean 등록 addAllowedOrigin() CORS 정책 적용 registerCorsConfiguration(), 모든 path에 대해 CORS 정책 적용Exception 발생 시 CORS Header 적용여부TestController.javapackage com.skt.scale.paas.server.controller;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.context.annotation.Configuration;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@Configuration@RestController@RequestMapping(\"/api\")public class TestController { @RequestMapping(value = \"/test/null\", method = RequestMethod.GET) public void resNull(String test) { throw new NullPointerException(); } @ExceptionHandler(NullPointerException.class) public ResponseEntity&lt;Object&gt; handleAll(Exception ex) { ex.printStackTrace(); return new ResponseEntity&lt;&gt;(ex.toString(), new HttpHeaders(), HttpStatus.INTERNAL_SERVER_ERROR); }}request 결과 NullPointerException 발생 및 500 에러 response origin, referer 헤더에 따른 CORS 헤더는 정상적으로 반환" } ]
